#include <iostream>

/** Нахождение следующей последовательности
 * Найдем такую самую правую открывающую скобку, которую мы имеем право заменить
 * на закрывающую (так, чтобы в этом месте правильность не нарушалась), а всю
 * оставшуюся справа строку заменим на лексикографически минимальную: т.е.
 * сколько-то открывающих скобок, затем все оставшиеся закрывающие скобки. Иными
 * словами, мы пытаемся оставить без изменения как можно более длинный префикс
 * исходной последовательности, а в суффиксе эту последовательность заменяем на
 * лексикографически минимальную.
 * Осталось научиться искать эту самую позицию первого изменения. Для этого
 * будем идти по строке справа налево и поддерживать баланс depth открытых и
 * закрытых скобок (при встрече открывающей скобки будем уменьшать depth, а при
 * закрывающей — увеличивать). Если в какой-то момент мы стоим на открывающей
 * скобке, а баланс после обработки этого символа больше нуля, то мы нашли самую
 * правую позицию, от которой мы можем начать изменять последовательность (в
 * самом деле, depth > 0 означает, что слева имеется не закрытая ещё скобка).
 * Поставим в текущую позицию закрывающую скобку, затем максимально возможное
 * количество открывающих скобок, а затем все оставшиеся закрывающие скобки, —
 * ответ найден. Если мы просмотрели всю строку и так и не нашли подходящую
 * позицию, то текущая последовательность — максимальна, и ответа не существует.
 *
 * @param s Изначальная скобочная последовательность
 * @return Следцующая в лексиграфическом порядке скобочная последовательность
 */
std::string getNext(std::string s) {
  int n = s.length();
  int depth{0};  // текущее количество открытых скобок
  std::string ans = "0";
  for (int i = n - 1; i >= 0; --i) {  // идём по строке справа налево
    // поддерживаем баланс открытых и закрытых скобок:
    // при встрече открывающей скобки будем уменьшать depth, а при закрывающей —
    // увеличивать
    s[i] == '(' ? --depth : ++depth;
    // Если в какой-то момент мы стоим на открывающей скобке, а баланс после
    // обработки этого символа больше нуля, то мы нашли самую правую позицию, от
    // которой мы можем начать изменять последовательност
    if (s[i] == '(' && depth > 0) {
      --depth;
      int open = (n - i - 1 - depth) / 2;
      int close = n - i - 1 - open;
      // Поставим в текущую позицию закрывающую скобку, затем максимально
      // возможное количество открывающих скобок, а затем все оставшиеся
      // закрывающие скобки
      ans = s.substr(0, i) + ')' + std::string(open, '(') +
            std::string(close, ')');
      break;
    }
  }
  return ans;
}

int main() {
  int n{0};
  scanf("%d", &n);
  std::string s;
  s = std::string(n, '(') + std::string(n, ')');
  std::cout << s << std::endl;
  while (s = getNext(s), s != "0") {
    std::cout << s << std::endl;
  };
  return 0;
}
